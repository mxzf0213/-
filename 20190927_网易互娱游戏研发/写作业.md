## 题目描述

小学生小明刚刚学会了使用竖式计算三位数乘法，为了更熟练地使用竖式，老师给他布置了N道算术题。但是这个N很多，小明感觉非常不高兴，为什么我不能用计算机去计算这些结果？但是作业要求要把竖式过程写出来，不能直接写结果糊弄老师。

没办法，小明在写作业的时候开始了他的苦中作乐：他打算算出今天写到的最多的数字(1，2，3，4，5，6，7，8，9，小明不喜欢数字0)是哪一个，作为今天的幸运数字。但是小明发现数数字也是件很麻烦的事情，他想:为什么我不能写个程序去帮我计算这个幸运数字呢？于是小明动起手来。但当他写完识別数字的图像识别程序后发现已经很晚了，然而作业只写到一半，所以他必须先继续去写乘法竖式。但是眼看十二点的钟声就要敲响，小明实在非常想知道今天的幸运数字是什么，于是他拜托你帮忙计算幸运数字。

对于小明的竖式乘法，下方说明会有更详细的定义。

## 输入描述

每个输入数据包含一个测试点。

第一行为一个正整数N（0 < N < 10000），表示老师布置的题目数。

接下来N行，每行两个非负整数a，b（0 < a, b < 1000），表示这一题需要小明使用竖式计算a * b。

## 输出描述

输出N+1行，前N行每行包括9个使用空格隔开的数字，第i行表示输入中的第i题需要写的数字的个数分别是多少 。该行第一个数字是数字1写的次数，该行第二个数字是数字数字2写的次数，以此类推。

最后一行(即第N+1行)只有一个数字，即今天小明会写到的数字里次数最多的那个数字。如果有多个数字写的次数相，则会选最小的那个数字。

若1和2都写了2333次，其他数字写的次数是0，那么今天的幸运数字就是1。

注意，小明不喜欢数字0！

需要特别说明的是，小明绝对不会算错数字。

## 示例1  

### 输入

3

123 456

15 20

20 15

### 输出

2 2 2 2 3 3 1 3 1

1 1 2 0 1 0 0 0 0

2 2 1 0 1 0 0 0 0

1

## 思路

暴力模拟一遍乘法即可。

## 代码

```c++
#include <bits/stdc++.h>
using namespace std;
const int maxn=1e5+10,mod=998244353;
typedef long long ll;
int n,m,k,t;
int num[10];
int main()
{
    int i,j;
    //freopen("in.txt","r",stdin);
    scanf("%d",&t);
    while(t--)
    {
        int a,b;
        scanf("%d%d",&a,&b);
        int c=a;
        int temp[10]={0};
        while(c)
        {
            temp[c%10]++;
            c/=10;
        }
        c=b;
        while(c)
        {
            temp[c%10]++;
            c/=10;
        }
        c=b;
        while(c)
        {
            int cur=c%10*a;
            while(cur)temp[cur%10]++,cur/=10;
            c/=10;
        }
        c=b*a;
        while(c)
        {
            temp[c%10]++;
            c/=10;
        }
        for(i=1;i<=9;i++)printf("%d%c",temp[i],i==9?'\n':' ');
        for(i=0;i<10;i++)num[i]+=temp[i];
    }
    int mx=-1,id=-1;
    for(i=9;i>=1;i--)
    {
        if(mx<=num[i])mx=num[i],id=i;
    }
    printf("%d\n",id);
    return 0;
}
```

