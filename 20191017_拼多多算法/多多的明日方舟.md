## 题目描述

多多鸡最近迷上了一款叫明日方舟的游戏。游戏的内容大概就是部署不同的干员，击败敌人。每个干员都有星级，总体而言，星级越高的干员越强力，游戏里干员的最高星级是六星。获取干员的方式一般是通过招募，为了给自己更好的游戏体验，多多鸡决定将这个游戏里的所有六星干员都招募了。

每次招募来的干员都是随机的，每次招募有x的几率招募到六星干员。游戏考虑到玩家的体验，设立了保底的机制，每当连续k次没有招募到六星干员，招募到六星干员的几率都会上升y。举例来讲，如果连续k次没招募到六星干员，那么第k+1次招募，招募到六星干员的几率就是x+y，第k+2次招募到六星干员的理论几率就是x + 2 * y，依次类推。若某次招募到六星干员的理论概率大于等于1时，这一次就必然会招募到六星干员。招募到六星干员后，保底机制会重置，下一次招募到六星干员的几率恢复为x。

需要注意的是，招募到每个六星干员的几率都是相等的。既有可能招募到已经拥有的六星干员，这种情况下，对多多鸡收集全部六星干员的目标是没有帮助的。

多多鸡在计划招募全部六星干员之前，已经拥有n个六星干员中的m个了，并且之前已经连续招募了t次没有招募到六星干员。

多多鸡想知道，在这种情况下，达成招募到全部六星干员的目标的期望招募次数是多少。

## 输入描述

共一行，四个整数n，m，t，k加上两个实数x，y。

## 输出描述

共一行，表示达成招募到全部六星干员的目标的期望招募次数，保留两位小数。

## 示例1

### 输入

1 0 98 50 0.02 0.02

### 输出

1.00

## 示例2

### 输入

14 2 30 50 0.02 0.02

### 输出

1490.12

## 思路

期望 = 概率 * 贡献，这个是算期望的基础公式。（公式1）

假设每次抽中一种六星干员的概率为x（独立同分布），那么抽中的期望次数为1/x。（公式2）

那么有： 已知抽中了p个六星干员，且当前再抽中一个六星干员的期望次数为y，再抽中一个新的六星干员的期望次数为y * n / （n - p）。

首先算出

1）已经抽了t次，再抽能够获得一个六星干员的期望次数。

2）从头开始抽获得一个六星干员的期望次数。

分两种情况：

1）第一次抽中了之前没有招募到的，即不是m中的任何一个；

2）第一次抽中了之前招募到的，即m中的一个。

最后套用公式推导即可，详见代码。

## 代码

```c++
#include <bits/stdc++.h>
using namespace std;
const int maxn=5e3+10,mod=1e9+7;
typedef long long ll;
int n,m,k,t;
int main()
{
    int i,j;
    //freopen("in.txt","r",stdin);
    scanf("%d%d%d%d",&n,&m,&t,&k);
    double x,y;
    scanf("%lf%lf",&x,&y);
    double ret=0;
    double cur=0;
    double delta=1;
    for(i=t+1;i<=k;i++)
    {
        cur+=delta*x*(i-t);
        delta*=(1-x);
    }
    double p=x+y*(t>k?(t-k):0);
    for(i=max(k+1,t+1);;i++)
    {
        p+=y;
        if(p>=1)p=1;
        cur+=delta*p*(i-t);
        delta*=(1-p);
        if(p>=1)break;
    }
    double save = cur;
    cur=0;
    delta=1;
    for(i=1;i<=k;i++)
    {
        cur+=delta*x*i;
        delta*=(1-x);
    }
    p=x+y;
    for(i=k+1;;i++)
    {
        if(p>=1)p=1;
        cur+=delta*p*i;
        delta*=(1-p);
        if(p>=1)break;
        p+=y;
    }
    for(i=0;i<2;i++)
    {
        if(i==0)
        {
            ret+=save;
            for(j=1;j<n-m;j++)
                ret+=(1.*n/(n-m-j))*cur;
            ret*=(1.*(n-m)/n);
        }
        else
        {
            double now=0;
            for(j=0;j<n-m;j++)
            {
                now+=(1.*n/(n-m-j))*cur;
            }
            now+=save;
            now*=(1.*m/n);
            ret+=now;
        }
    }
    printf("%.2f\n",ret);
    return 0;
}

```

